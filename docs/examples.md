> **Note**: This documentation was primarily generated by AI (Claude Sonnet 4.5). While the content is derived from the thesis, inaccuracies may occur. You can open an issue or PR for reporting inaccuracies or unclear explanations.

# Trale Examples Guide

This document walks through the key examples in the TraleTest directory, explaining their purpose and teaching concepts progressively.

## Table of Contents

1. [Zmod5: A Complete Example](#zmod5-a-complete-example)
2. [Comparing Proof Approaches](#comparing-proof-approaches)
3. [Manual vs Automated Transfer](#manual-vs-automated-transfer)
4. [Summable Sequences](#summable-sequences)
5. [Induction Principles](#induction-principles)
6. [Advanced Topics](#advanced-topics)

## Zmod5: A Complete Example

**Location**: `TraleTest/Lemmas/Zmod5.lean`

This is the canonical example showing all components needed for proof transfer.

### Step 1: Define the Type

```lean
abbrev Zmod5 := Fin 5  -- Integers modulo 5
```

### Step 2: Define Transport Functions

```lean
def mod5 (n : Nat) : Zmod5 := ⟨n % 5, mod5_le5⟩
def repr5 (a : Zmod5) : Nat := a.val
```

- `repr5` extracts the natural number representation
- `mod5` constructs a Zmod5 from a natural number

### Step 3: Prove Retraction

```lean
lemma repr5K : ∀ (a : Zmod5), mod5 (repr5 a) = a := by
  intro a
  dsimp [repr5, mod5]
  congr
  apply lt_mod_eq
  simp
```

This proves `mod5 ∘ repr5 = id`, making repr5 a retraction.

### Step 4: Create Param Instance

```lean
instance ModParam : Param2a4 Zmod5 Nat := by 
  tr_from_map repr5K
```

The `tr_from_map` tactic automatically constructs a split surjection from the retraction proof.

### Step 5: Define Operation Transport

```lean
@[trale]
def R_add_Zmod5
  (a b : Zmod5) (a' b' : Nat)
  (aR : tr.R a a')
  (bR : tr.R b b')
  : (tr.R (a + b) (a' + b')) := by
  tr_whnf  -- Reduce to normal form
  subst aR bR  -- Use relation equalities
  -- Prove the addition result matches
  change (⟨(a' + b') % 5, _⟩ : Zmod5) = Fin.add (⟨a' % 5, _⟩) (⟨b' % 5, _⟩)
  ext
  simp [Fin.add]
  omega
```

The `@[trale]` attribute registers this for automatic use.

### Step 6: Handle Literals

```lean
instance zmod5OfNat : OfNat Zmod5 x := Fin.instOfNat

@[trale]
def R_ofNat_Zmod5 (n : Nat)
  : tr.R (zmod5OfNat (x := n)) (instOfNatNat (n := n)) := by 
  rfl
```

This handles numeric literals like `0`, `1`, `2` in the goal.

### Step 7: Using the Trale Tactic

```lean
theorem sum_eq_reverse_sum_Zmod5 : ∀ (a b c : Zmod5),
  (a + b) + c = (c + b) + a := by
  trale
  omega
```

The `trale` tactic:
1. **Automatically discovers and registers** `Param` instances (no manual registration needed!)
2. Reverts all variables
3. Translates goal to Nat
4. Solves parametricity obligations
5. Leaves simplified goal for `omega`


## Comparing Proof Approaches

**Location**: `TraleTest/Transfer/lst01_reverse_sum_generic.lean`

This file compares three approaches to the same theorem.

### Approach 1: Parallel Proofs

```lean
-- Proof on Nat
theorem sum_eq_reverse_sum_Nat (a b c : Nat)
  : (a + b) + c = (c + b) + a := by
  rw [Nat.add_comm _ c, Nat.add_comm a b]
  simp [Nat.add_assoc]

-- Proof on Zmod5 (duplicated logic)
theorem sum_eq_reverse_sum_Zmod5 (a b c : Zmod5)
  : (a + b) + c = (c + b) + a := by
  rw [Zmod5.add_comm _ c, Zmod5.add_comm a b]
  simp [Zmod5.add_assoc]
```

**Issues**: Duplication, must define `add_comm` and `add_assoc` for each type.

### Approach 2: Generic Proofs

```lean
-- Generic proof using typeclasses
theorem sum_eq_reverse_sum {G : Type*} 
  [AddCommSemigroup G] (a b c : G)
  : (a + b) + c = (c + b) + a := by
  rw [AddCommMagma.add_comm _ c, AddCommMagma.add_comm a b]
  simp [AddSemigroup.add_assoc]

-- Instantiate for each type
instance : AddCommSemigroup Zmod5 := ...
theorem sum_eq_reverse_sum_Zmod5 := sum_eq_reverse_sum
```

**Benefits**: No duplication, mathematically clean.
**Issues**: Requires defining typeclasses, less direct, can't use type-specific tactics.

### Approach 3: Proof Transfer (with Trale)

```lean
theorem sum_eq_reverse_sum_Nat (a b c : Nat)
  : (a + b) + c = (c + b) + a := by
  omega  -- Can use Nat-specific automation!

theorem sum_eq_reverse_sum_Zmod5 (a b c : Zmod5)
  : (a + b) + c = (c + b) + a := by
  trale  -- Automatically transfers from Nat
  omega
```

**Benefits**: 
- Use type-specific automation (omega works on Nat but not generic types)
- Minimal boilerplate (just define relations once)
- Natural incremental development

## Manual vs Automated Transfer

**Location**: `TraleTest/Transfer/lst20_22_reverse_sum_trale.lean`

This demonstrates the progression from manual to automated proof transfer.

### Manual Version (Listing 20a)

```lean
theorem sum_eq_reverse_sum_Zmod5_manual (a b c : Zmod5)
  : (a + b) + c = (c + b) + a := by
  revert a b c
  refine Param.right' ?_ sum_eq_reverse_sum_Nat
  
  apply Map1_forall; intro a a' aR
  case p1 => exact ModParam.forget
  
  apply Map1_forall; intro b b' bR
  case p1 => exact ModParam.forget
  
  apply Map1_forall; intro c c' cR
  case p1 => exact ModParam.forget
  
  apply R_eq
  · apply R_add_Zmod5; apply R_add_Zmod5
    exact aR; exact bR; exact cR
  · apply R_add_Zmod5; apply R_add_Zmod5
    exact cR; exact bR; exact aR
```

Each step is explicit:
- `refine Param.right'` starts the transfer
- `Map1_forall` handles each universal quantifier
- `R_eq` relates the two sides of the equality
- `R_add_Zmod5` propagates relations through addition

### Semi-Automated Version (Listing 20c)

```lean
theorem sum_eq_reverse_sum_Zmod5_manual5 (a b c : Zmod5)
  : (a + b) + c = (c + b) + a := by
  revert a b c
  refine Param.right' ?_ sum_eq_reverse_sum_Nat
  
  repeat first
    | apply Map1_forall
      case' p2 => intro _ _ _
      case p1 => infer_instance
    | apply R_eq
    | apply R_add_Zmod5
    | assumption
```

Uses Lean's `repeat first` to try tactics in order until one succeeds.

### Fully Automated Version (Listing 22)

```lean
theorem sum_eq_reverse_sum_Zmod5 (a b c : Zmod5)
  : (a + b) + c = (c + b) + a := by
  trale
  omega
```

The `trale` tactic handles everything automatically!

## Summable Sequences

**Location**: `TraleTest/Transfer/SummableSequence_*.lean`

This example shows transport for sequences and infinite sums.

### The Setup

```lean
-- A sequence is summable if its infinite sum converges
def IsSummable (u : Nat → Real) : Prop :=
  ∃ s, (∑' i, u i) = s

-- We want to relate sequences on Nat and sequences on Fin n
```

### Challenge: Partial Functions

The difficulty: `Fin n` has finitely many elements, but `Nat` is infinite. We need to extend Fin n sequences to Nat:

```lean
def extend (u : Fin n → Real) : Nat → Real
  | i => if h : i < n then u ⟨i, h⟩ else 0
```

This is a **split surjection**: every finite sequence extends to an infinite one uniquely (by padding with zeros).

### The Parametric Relation

```lean
instance : Param42a (Fin n → Real) (Nat → Real) := by
  tr_from_map extend_section
  where
    extend_section : ∀ u : Fin n → Real, 
      restrict (extend u) = u
```

### Transport Theorem

```lean
theorem summable_extend (u : Fin n → Real)
  : IsSummable (extend u) ↔ True := by
  -- Finite sequences are always summable!
  constructor <;> intro
  · trivial
  · exists (∑ i, u i)
    simp [extend]
```

This demonstrates how Trale can handle domain extensions gracefully.

## Induction Principles

**Location**: `TraleTest/Transfer/InductionPrinciple_v*.lean`

A series of files (v1 through v6) showing progressive refinement of transferring induction principles.

### The Problem

Natural number induction:
```lean
theorem nat_induction (P : Nat → Prop)
  (base : P 0)
  (step : ∀ n, P n → P (n + 1))
  : ∀ n, P n
```

Can we transfer this to a custom inductive type?

### Custom Inductive Type

```lean
inductive I : Type
  | zero : I
  | succ : I → I
```

### The Challenge

Induction involves:
- A predicate `P : Nat → Prop` that becomes `P' : I → Prop`
- Quantification over predicates (higher-order)
- Dependent types (P depends on the value)

### Solution Sketch

```lean
@[trale]
def R_pred
  [Param2a0 Nat I]
  (P : Nat → Prop) (P' : I → Prop)
  (h : ∀ n n', tr.R n n' → (P n ↔ P' n'))
  : Param10 (∀ n, P n) (∀ n', P' n') := ...
```

The versions v1-v6 show progressive debugging and refinement of this approach, eventually arriving at a working transfer of the induction principle.

## Advanced Topics

### Metric Spaces

**Location**: `TraleTest/Transfer/lst29_MetricQuestionFromZulip.lean`

Demonstrates transferring theorems about metric spaces between equivalent representations (e.g., `V` and `Fin 2 → ℝ` for 2D vector spaces).

**Challenge**: Dealing with typeclasses and instances in transport.

### Generalized Rewriting

**Location**: `TraleTest/Transfer/lst30_GenRewrite.lean`

Shows using Trale for rewriting under a different relation (not just equality).

```lean
@[trale]
theorem add_morph
  {m m' : Nat} (mR : m ≤ m')
  {n n' : Nat} (nR : n ≤ n')
  : m + n ≤ m' + n' :=
  Nat.add_le_add mR nR

theorem example (i j : Nat) (ji : j ≤ i)
  : j + i + j ≤ i + i + i := by
  tr_by (le_refl i)  -- Rewrite j to i under ≤ relation
  tr_solve
```

This shows Trale can handle relations beyond equality.

### Double Commutativity

**Location**: `TraleTest/Transfer/DoubleCommuntes.lean`

Transfer theorems involving multiple operations:

```lean
theorem double_commute_nat (a b c d : Nat)
  : (a + b) * (c + d) = (c + d) * (a + b) := by
  ring

theorem double_commute_zmod5 (a b c d : Zmod5)
  : (a + b) * (c + d) = (c + d) * (a + b) := by
  trale
  ring
```

Shows Trale handles multiple operations in a single transport.

## Tips for Creating Your Own Examples

1. **Start Simple**: Begin with one operation (like addition) before adding more

2. **Test Transport Manually First**: Before using `trale`, try writing out the manual transport to understand what's needed

3. **Check Relations**: Use `#check tr.R a b` to see what relation is being used

4. **Debug with repeat tr_advance**: Instead of `tr_solve`, use `repeat tr_advance` to see where it gets stuck

5. **Add Trace**: Use `set_option trace.trale true` to see what Trale is doing

6. **Build Incrementally**: Start with `Param10`, then add properties to reach `Param44`

---

For theory background, see [theory.md](theory.md).  
For implementation details, see [implementation.md](implementation.md).  
To get started, see [getting-started.md](getting-started.md).
