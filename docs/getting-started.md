> **Note**: This documentation was primarily generated by AI (Claude Sonnet 4.5). While the content is derived from the thesis, inaccuracies may occur. You can open an issue or PR for reporting inaccuracies or unclear explanations.

# Getting Started with Trale

This tutorial will guide you through setting up and using Trale for proof transfer in Lean 4.

## Table of Contents

1. [Installation](#installation)
2. [Your First Transfer](#your-first-transfer)
3. [Understanding the Components](#understanding-the-components)
4. [Common Patterns](#common-patterns)
5. [Troubleshooting](#troubleshooting)
6. [Next Steps](#next-steps)

## Installation

### Prerequisites

You need Lean 4 (version 4.23.0-rc2 or compatible) and Lake installed. If you don't have them:

1. Install [elan](https://github.com/leanprover/elan) (Lean version manager)
2. elan will automatically install the correct Lean version when you open the project

### Getting Trale

```bash
git clone https://github.com/vkuhlmann/trale.git
cd trale
```

### Getting Mathlib Cache

**Important**: This saves hours of compilation time!

```bash
lake exe cache get
```

### Building Trale

```bash
lake build
```

This compiles the Trale library. It should take a few minutes.

### Verify Installation

```bash
lake build TraleTest.Lemmas.Zmod5
```

If this succeeds, you're all set!

## Your First Transfer

Let's create a simple proof transfer from natural numbers to a custom type.

### Step 1: Create a New File

Create `MyFirst.lean` in the project root:

```lean
import Trale.Utils.Basic
import Trale.Utils.Attr
```

### Step 2: Define Your Custom Type

```lean
-- Natural numbers modulo 3
inductive Mod3 : Type
  | zero : Mod3
  | one : Mod3
  | two : Mod3
  deriving DecidableEq

namespace Mod3
```

### Step 3: Define Addition

```lean
def add : Mod3 â†’ Mod3 â†’ Mod3
  | zero, b => b
  | a, zero => a
  | one, one => two
  | one, two => zero
  | two, one => zero
  | two, two => one

instance : Add Mod3 := âŸ¨addâŸ©

-- Some basic properties
theorem add_zero (a : Mod3) : a + zero = a := by
  cases a <;> rfl

theorem zero_add (a : Mod3) : zero + a = a := by
  cases a <;> rfl
```

### Step 4: Connect to Natural Numbers

```lean
-- Convert Nat to Mod3
def ofNat : Nat â†’ Mod3
  | 0 => zero
  | 1 => one
  | 2 => two
  | n + 3 => ofNat n

-- Convert Mod3 to Nat
def toNat : Mod3 â†’ Nat
  | zero => 0
  | one => 1
  | two => 2

-- Prove the retraction property
theorem ofNat_toNat : âˆ€ (a : Mod3), ofNat (toNat a) = a := by
  intro a
  cases a <;> rfl
```

### Step 5: Create the Parametric Relation

```lean
open Trale

instance : Param2a4 Mod3 Nat := by
  tr_from_map ofNat_toNat
```

The `tr_from_map` tactic automatically creates a parametric relation from the retraction proof.

### Step 6: Define Transport for Addition

```lean
@[trale]
def R_add_Mod3
  (a b : Mod3) (a' b' : Nat)
  (aR : tr.R a a') (bR : tr.R b b')
  : tr.R (a + b) (a' + b') := by
  -- The relation is: toNat a = a'
  subst aR bR
  -- Now we need to prove: toNat (a + b) = a' + b'
  -- This requires showing that addition respects the encoding
  sorry  -- We'll come back to this
```

### Step 7: First Transfer Attempt

```lean
-- Theorem on Nat (trivial)
theorem nat_example (a b : Nat) : a + b = b + a := by
  omega

-- Try to transfer to Mod3
theorem mod3_example (a b : Mod3) : a + b = b + a := by
  trale
  -- This will get stuck because we haven't proven R_add_Mod3
```

### Step 8: Complete the Transport Lemma

Let's properly prove `R_add_Mod3`:

```lean
theorem add_respects_encoding (a b : Mod3)
  : toNat (a + b) = (toNat a + toNat b) % 3 := by
  cases a <;> cases b <;> rfl

@[trale]
def R_add_Mod3
  (a b : Mod3) (a' b' : Nat)
  (aR : tr.R a a') (bR : tr.R b b')
  : tr.R (a + b) (a' + b') := by
  subst aR bR
  dsimp [tr.R]
  rw [add_respects_encoding]
  omega
```

### Step 9: Success!

Now the transfer works:

```lean
theorem mod3_comm (a b : Mod3) : a + b = b + a := by
  trale
  omega
```

The `trale` tactic:
1. Reverts variables `a` and `b`
2. Translates the goal to `Nat`
3. Uses `R_add_Mod3` to transport addition
4. Leaves `âˆ€ a' b' : Nat, a' + b' = b' + a'` for `omega`

## Understanding the Components

### The Relation: tr.R

When you write `tr.R a a'`, this means "`a` and `a'` are related." In our example:

```lean
tr.R (x : Mod3) (x' : Nat) := (toNat x = x')
```

So `tr.R zero 0` holds, but `tr.R zero 1` doesn't.

### The Param Instance

```lean
instance : Param2a4 Mod3 Nat
```

This says:
- **2a** (covariant): We have a map `toNat : Mod3 â†’ Nat` with `toNat a = b â†’ R a b`
- **4** (contravariant): Full inverse structure from `Nat` to `Mod3`

The numbers refer to property levels (see [theory.md](theory.md) for details).

### The @[trale] Attribute

```lean
@[trale]
def R_add_Mod3 ...
```

This registers the lemma so `trale` can find it automatically. Without this attribute, you'd need to manually apply the lemma.

### The tr_solve Tactic

After `trale` translates the goal, `tr_solve` tries to:
1. Apply registered `@[trale]` lemmas
2. Use instance search for `Param` instances
3. Handle standard type constructors (forall, arrow, products, etc.)

## Common Patterns

### Pattern 1: Simple Bijection

When types are in 1-1 correspondence:

```lean
def to_other (a : MyType) : OtherType := ...
def from_other (b : OtherType) : MyType := ...

theorem to_from : âˆ€ a, from_other (to_other a) = a := ...
theorem from_to : âˆ€ b, to_other (from_other b) = b := ...

instance : Param44 MyType OtherType := by
  tr_from_equivalence to_from, from_to
```

### Pattern 2: Embedding (Injection)

When one type embeds into another:

```lean
def embed (a : Smaller) : Larger := ...
def project (b : Larger) : Smaller := ...

theorem embed_project : âˆ€ a, project (embed a) = a := ...

instance : Param42b Smaller Larger := by
  tr_from_map embed_project
```

### Pattern 3: Quotient (Surjection)

When one type is a quotient of another:

```lean
def quotient (a : Larger) : Smaller := ...
def lift (b : Smaller) : Larger := ...

theorem quotient_lift : âˆ€ a, quotient (lift a) = a := ...

instance : Param42a Smaller Larger := by
  tr_from_map quotient_lift
```

### Pattern 4: Operations

For each operation on your type:

```lean
@[trale]
def R_operation
  (inputs : MyType) (inputs' : OtherType)
  (inputsR : tr.R inputs inputs')
  : tr.R (operation inputs) (operation' inputs') := by
  -- Prove the operation respects the relation
  sorry
```

## Troubleshooting

### Error: "failed to synthesize instance Param..."

**Problem**: Trale can't find a parametric relation between types.

**Solution**: 
1. Check that you've defined the `Param` instance
2. Make sure it's in scope (use `open Trale` or full name)
3. Verify the map class is strong enough (might need `Param42b` instead of `Param10`)

### Error: "unsolved goals" after trale

**Problem**: Missing transport lemmas for operations.

**Solution**:
1. Identify which operation is missing (look at the goal)
2. Define an `@[trale]` lemma for that operation
3. Ensure the lemma is in scope

### Error: "maximum recursion depth"

**Problem**: Circular dependency in parametric relations.

**Solution**:
1. Check for cycles in your `Param` instances
2. Use explicit type annotations to break inference loops
3. Consider using `Param.forget` to weaken relations

### Trale is Slow

**Solutions**:
1. Use `repeat tr_advance` instead of `tr_solve` to see progress
2. Manually apply some steps with `tr_intro` before `tr_solve`
3. Build specific lemmas instead of relying on full automation
4. Check universe level issues (use `change Param.{0} _ _ _ _`)

### Can't Apply tr_from_map

**Problem**: The retraction doesn't have the right form.

**Solution**: tr_from_map expects `âˆ€ a, f (g a) = a`. If you have the opposite direction, you need `tr_from_involution` or manual construction:

```lean
instance : Param42b Î± Î² := by
  tr_constructor
  exact (f Â· = Â·)  -- R
  exact f          -- covariant map
  intro a b h; subst h; rfl  -- 2a
  -- ... continue with other properties
```

## Next Steps

### Learn More Theory

Read [theory.md](theory.md) to understand:
- The property hierarchy (0, 1, 2a, 2b, 3, 4)
- Why certain map classes are required for certain type constructors
- How dependent types are handled

### Study Examples

Check out [examples.md](examples.md) for:
- Complete walkthroughs of real examples
- Advanced patterns (induction principles, metric spaces)
- Comparison with other proof techniques

### Explore the Test Suite

Browse `TraleTest/` for:
- `TraleTest/Lemmas/` - Complete setups for various types
- `TraleTest/Transfer/` - Actual transfer examples
- `TraleTest/Research/` - Experimental features

### Contribute

Ideas for contributions:
1. Add transport lemmas for Mathlib types
2. Create examples for your domain
3. Improve automation (better Aesop rules)
4. Write more documentation

Check the GitHub repository for open issues and contribution guidelines.

### Join the Community

- **Lean Zulip**: [leanprover.zulipchat.com](https://leanprover.zulipchat.com)
- **Utrecht Formalization Group**: Weekly meetings on formal methods

## Quick Reference Card

### Essential Tactics

```lean
trale              -- Full automatic proof transfer
tr_by <theorem>    -- Transfer from a specific theorem
tr_solve           -- Solve parametricity obligations
tr_intro           -- Intro with Param splitting
tr_advance         -- One step of solving
repeat tr_advance  -- Semi-automated solving
```

### Construction Tactics

```lean
tr_constructor     -- Build Param from scratch
tr_extend <inst>   -- Extend existing Param with more properties
tr_from_map <pf>   -- Build from retraction proof
tr_from_equiv <e>  -- Build from equivalence (requires Mathlib)
```

### Common Param Classes

```lean
Param00   -- Just relation
Param10   -- Covariant map
Param2a0  -- Covariant + capture
Param42b  -- Split injection
Param44   -- Equivalence
```

### Attributes

```lean
@[trale]           -- Register transport lemma
```

---

**Congratulations!** You now know the basics of proof transfer with Trale. Happy proving! ðŸŽ‰
