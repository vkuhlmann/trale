> **Note**: This documentation was primarily generated by AI (Claude Sonnet 4.5). While the content is derived from the thesis, inaccuracies may occur. You can open an issue or PR for reporting inaccuracies or unclear explanations.

# Trale Implementation Details

This document describes the technical implementation of the Trocq framework in Lean 4.

## Table of Contents

1. [Core Structures](#core-structures)
2. [MapType System](#maptype-system)
3. [Constructing Parametric Relations](#constructing-parametric-relations)
4. [Forgetful and Flip Functors](#forgetful-and-flip-functors)
5. [Glueing](#glueing)
6. [Automation and Tactics](#automation-and-tactics)
7. [Theory Definitions](#theory-definitions)

## Core Structures

### The Param Class

The fundamental structure in Trale is the `Param` class:

```lean
class Param
  (mapCov : MapType)
  (mapContra : MapType)
  (α : Sort u) (β : Sort v)
where
  R : α → β → Sort w
  covariant : mapCov.interp R
  contravariant : mapContra.interp (flipRel R)
```

- `R` is the relation between types α and β
- `mapCov` specifies the property level in the covariant direction (α → β)
- `mapContra` specifies the property level in the contravariant direction (β → α)
- `flipRel R` reverses the relation: `flipRel R b a := R a b`

### Map Structures

The `MapX` structures implement the property levels:

```lean
structure Map0 (R : α → β → Sort w) : Type (max u v w)

structure Map1 extends Map0 R where
  map : α → β

structure Map2a extends Map1 R where
  map_in_R : ∀ a b, map a = b → R a b

structure Map2b extends Map1 R where
  R_in_map : ∀ a b, R a b → map a = b

structure Map3 extends Map2a R, Map2b R

structure Map4 extends Map3 R where
  R_in_mapK : ∀ a b (r : R a b), 
    map_in_R a b (R_in_map a b r) = r
```

Each structure extends previous ones, forming a hierarchy matching the theoretical property levels.

## MapType System

### The MapType Inductive

To ensure only valid map structures are used, Trale uses an enumeration:

```lean
inductive MapType where
  | Map0
  | Map1
  | Map2a
  | Map2b
  | Map3
  | Map4
  deriving DecidableEq, Repr
```

### Interpretation Function

The `interp` function converts `MapType` to actual map structures:

```lean
def MapType.interp (mapType : MapType) (R : α → β → Sort w) :=
  match mapType with
  | .Map0  => Map0 R
  | .Map1  => Map1 R
  | .Map2a => Map2a R
  | .Map2b => Map2b R
  | .Map3  => Map3 R
  | .Map4  => Map4 R
```

### Partial Order

MapType has a partial order reflecting the property hierarchy:

```lean
instance : LE MapType where
  le m1 m2 := -- implements the property hierarchy ordering

instance : DecidableLE MapType  -- Can decide ordering at compile time
```

This enables:
- Automatic verification that properties are sufficient
- Compile-time checking of map class requirements
- The forgetful functor (weakening to lower property levels)

### Abbreviations

For convenience, Trale provides abbreviations:

```lean
abbrev Param00  := Param .Map0 .Map0
abbrev Param10  := Param .Map1 .Map0
abbrev Param2a0 := Param .Map2a .Map0
abbrev Param44  := Param .Map4 .Map4
-- ... and so on
```

## Constructing Parametric Relations

### The tr_constructor Tactic

The `tr_constructor` tactic simplifies creating `Param` instances:

```lean
instance Map1_prod
  [Param10 α α'] [Param10 β β']
  : Param10 (α × β) (α' × β') := by
  tr_constructor
  -- Goal 1: Define R
  intro (a, b) (a', b')
  exact (tr.R a a') × (tr.R b b')
  -- Goal 2: Define covariant map
  intro (a, b)
  exact (tr.map a, tr.map b)
```

Benefits:
- Natural ordering (R first, then properties in dependency order)
- Flattened field names (`right` instead of `covariant.map`)
- Automatic goal generation

### The tr_extend Tactic

Build on existing instances to add properties:

```lean
instance Map2a_prod
  [Param2a0 α α'] [Param2a0 β β']
  : Param2a0 (α × β) (α' × β') := by
  tr_extend Map1_prod
  -- Only prove the new property (2a)
  intro (a, b) (a', b') h
  cases h
  exact ⟨tr.map_implies_R _ _ ‹_›, tr.map_implies_R _ _ ‹_›⟩
```

### Constructing from Functions

Helper constructors for common patterns:

```lean
-- From a simple map
def paramFromMap (f : α → α') : Param40 α α' := by
  tr_constructor
  exact (f · = ·)  -- R is graph of f
  exact f

-- From split injection (injective with explicit inverse)
def paramFromInjection
  {sect : α → α'} {retract : α' → α}
  (sectK : ∀ a, retract (sect a) = a)
  : Param42b α α' := by
  tr_extend paramFromMap sect
  exact retract
  intro _ _ h; subst h; exact sectK _

-- From equivalence
def paramFromEquiv (h : α ≃ β) : Param44 α β := by
  tr_constructor
  exact (h · = ·)
  exact h; -- property proofs...
  exact h.symm; -- property proofs...
```

## Forgetful and Flip Functors

### Forgetful Functor

Weaken parametric relations to lower property levels:

```lean
def Param.forget
  {X Y X' Y' : MapType}
  (h1 : X' ≤ X := by decide)
  (h2 : Y' ≤ Y := by decide)
  (p : Param X Y α β)
  : Param X' Y' α β :=
  { R := p.R,
    covariant := coeMap p.covariant h1,
    contravariant := coeMap p.contravariant h2 }
```

The `by decide` autoparams automatically prove the ordering when possible:

```lean
example (p : Param2a0 α β) : Param10 α β := p.forget  -- Works automatically
```

### Flip Functor

Swap covariant and contravariant directions:

```lean
instance [p : Param X Y α β] : Param Y X β α :=
  { R := flipRel p.R,
    covariant := p.contravariant,
    contravariant := p.covariant }
```

This is defined as an instance, so flipping happens automatically:

```lean
def example1 : Param42b Nat Zmod5 := ...  -- Defined once
def example2 : Param2b4 Zmod5 Nat := example1.flip  -- Automatic
```

### Coercions

Lean's coercion system handles weakening MapX structures:

```lean
instance : Coe (Map2a R) (Map1 R) where coe m := m.toMap1
instance : Coe (Map4 R) (Map3 R) where coe m := m.toMap3
-- ... and so on
```

This allows passing stronger maps where weaker ones are expected.

## Glueing

Glueing combines two parametric relations with compatible overlap:

```lean
def glue
  (p1 : Param X1 Y1 α β)  -- e.g., Param2a0
  (p2 : Param X2 Y2 α β)  -- e.g., Param2b0
  (h : p1.R = p2.R)        -- Same relation
  : Param (X1 ∪ X2) (Y1 ∪ Y2) α β  -- e.g., Param30
```

### Example: Glueing Arrow Types

```lean
instance Param2a1_arrow
  [Param12b α α'] [Param2a1 β β']
  : Param2a1 (α → β) (α' → β') := by
  tr_extend_multiple [
    Map2a_arrow,      -- Provides covariant 2a
    Map1_arrow_flipped -- Provides contravariant 1 (via flip)
  ]
```

The `tr_extend_multiple` tactic handles glueing automatically when:
- Relations coincide (checked automatically)
- Properties don't conflict (Map classes are compatible)

### Dynamic Glueing

Trale can dynamically construct glued instances:

```lean
instance inferGlued
  [p1 : Param X1 Y1 α β]
  [p2 : Param X2 Y2 α β]
  [DecidableEq (α → β → Sort w)]
  : Param (X1 ∪ X2) (Y1 ∪ Y2) α β :=
  glue p1 p2 (by decide)  -- Relation equality checked at compile time
```

This eliminates the need for explicit glued definitions in most cases.

## Automation and Tactics

### The trale Tactic

The main user-facing tactic:

```lean
macro "trale" : tactic => `(tactic|
  focus
    trale'           -- Core translation logic
    change Param.{0} _ _ _ _  -- Fix universe levels
    tr_solve         -- Solve parametricity goals
)
```

### Core Translation (trale')

The `trale'` tactic:
1. Gets the current goal type
2. Recursively translates it using registered parametric relations
3. Generates two subgoals:
   - Parametric relation goal
   - Translated goal on the simpler type

### Helper Tactics

**tr_split**: Breaks down composite types
```lean
-- Splits Param goals for arrows, products, etc.
tr_split  -- Tries all known splitting strategies
tr_split_arrow  -- Specifically for arrow types
```

**tr_intro**: Split and introduce variables
```lean
tr_intro a b c  -- Like intro, but splits Param goals first
```

**tr_advance**: One step of goal solving
```lean
tr_advance  -- Applies splitting, instance search, and registered lemmas
```

**repeat tr_advance**: Semi-automated solving
```lean
-- Repeatedly applies tr_advance until stuck
repeat first
  | tr_advance
  | assumption
```

### The @[trale] Attribute

Registers lemmas for automatic use:

```lean
@[trale]
def R_add_Zmod5
  (aR : tr.R a a') (bR : tr.R b b')
  : tr.R (a + b) (a' + b') := ...
```

Under the hood:
- Adds lemma to Aesop ruleset
- Configures as 90% confidence apply rule
- Makes available to `tr_solve` tactic

### Aesop Integration

The `tr_solve` tactic wraps Aesop:

```lean
macro "tr_solve" : tactic => `(tactic| 
  aesop (rule_sets := [trale]) (options := {...})
)
```

- Uses dedicated `trale` ruleset (doesn't interfere with other Aesop usage)
- Configured for parametricity goal structure
- Enables backtracking when needed

### The tr_exact Tactic

Combines translation and solving:

```lean
theorem example_theorem : ∀ a b : Zmod5, a + b = b + a := by
  revert a b
  tr_exact nat_theorem  -- Translates nat_theorem and solves parametricity
```

Equivalent to:
```lean
  tr_by nat_theorem
  change Param.{0} _ _ _ _
  tr_solve
```

## Theory Definitions

### Parametric Relations for Sorts

Relating universes enables higher-order transport:

```lean
def sortParam (cov con : MapType) : Param2a2a (Sort u) (Sort u) := by
  tr_constructor
  -- R relates types that have parametric relations
  exact Param.{0,u,u} cov con
  -- Map is identity on types
  exact id
  -- Properties...
```

### Parametric Identity

The identity relation:

```lean
def Param44_ident : Param44 α α := by
  tr_constructor
  exact Eq  -- Relation is equality
  exact id
  repeat simp
  exact id
  repeat simp
```

### Propagating Relations

Core definitions in `Trale.Theories`:

**Forall**:
```lean
instance Map1_forall
  [Param01 α α'] [Param10 β β']
  : Param10 (∀ x : α, β) (∀ x' : α', β') := ...
```

**Arrow** (non-dependent):
```lean
instance Map1_arrow
  [Param01 α α'] [Param10 β β']
  : Param10 (α → β) (α' → β') := ...
```

**Products**:
```lean
instance Map1_prod
  [Param10 α α'] [Param10 β β']
  : Param10 (α × β) (α' × β') := ...
```

**Equality**:
```lean
def R_eq
  [Param2b0 α α']
  (aR : tr.R a a') (bR : tr.R b b')
  : Param10 (a = b) (a' = b') := ...
```

These are defined for all appropriate map class combinations, forming a comprehensive library of transport lemmas.

## Performance Considerations

### Universe Levels

Universe level metavariables can cause issues. The pattern:
```lean
change Param.{0} _ _ _ _  -- Fix relation universe to 0 (Prop)
```
helps Aesop avoid getting stuck on universe unification.

### Instance Search

- Use `@[instance priority]` for disambiguation
- Avoid overlapping instances without clear priority
- Use `inferInstance` when you know the instance exists

### Compilation Time

- Glued instances compile faster than explicit definitions
- `tr_solve` can be slow on complex goals (use `repeat tr_advance` for inspection)
- Cache commonly-used parametric relations in instances

---

For the theoretical foundations, see [theory.md](theory.md).  
For practical usage, see [getting-started.md](getting-started.md) and [examples.md](examples.md).
