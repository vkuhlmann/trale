> **Note**: This documentation was primarily generated by AI (Claude Sonnet 4.5). While the content is derived from the thesis, inaccuracies may occur. You can open an issue or PR for reporting inaccuracies or unclear explanations.

# Trocq Framework: Theoretical Foundations

This document explains the mathematical theory behind the Trocq framework as implemented in Trale.

## Table of Contents

1. [Introduction to Proof Transfer](#introduction-to-proof-transfer)
2. [The Trocq Primitives](#the-trocq-primitives)
3. [Property Hierarchy](#property-hierarchy)
4. [Characterizing Relations](#characterizing-relations)
5. [Type Formers: Arrow and Pi Types](#type-formers-arrow-and-pi-types)
6. [Universe Relations](#universe-relations)

## Introduction to Proof Transfer

### The Problem

In mathematics, we use notations flexibly. For example, if we prove `a + b + c = c + b + a` for all natural numbers, it's intuitively clear the same holds for ℤ/5ℤ. However, in type theory:

- Terms of each type have their own encoding
- Results cannot automatically carry between types
- Even equivalent types require explicit conversion

### The Solution: Parametric Relations

The key idea is to relate types through a **parametric relation**. If we have:
- A relation `R : α → β → Prop` describing when elements correspond
- Transport functions `f : α → β` and `g : β → α`
- Proofs that these functions respect the relation

Then we can systematically transport theorems from `α` to `β`.

### Example: Natural Numbers to Modular Arithmetic

Consider transporting from `Nat` to `Zmod5`:

```lean
-- Define the relation
def R (n : Nat) (z : Zmod5) : Prop := 
  mod5 n = z
  
-- Transport functions
def mod5 (n : Nat) : Zmod5 := ⟨n % 5, proof⟩
def repr5 (z : Zmod5) : Nat := z.val

-- Key property: repr5 is a retraction
lemma repr5K : ∀ z, mod5 (repr5 z) = z
```

With this setup, a proof of `∀ a b c : Nat, (a + b) + c = (c + b) + a` can be transferred to prove `∀ a b c : Zmod5, (a + b) + c = (c + b) + a`.

## The Trocq Primitives

### Describing Relations via a Graph

The fundamental innovation of Trocq is representing relations through a bipartite graph:

- **Vertices**: Elements `a : α` and `b : β`
- **Edges**: Terms `r : R a b` witnessing the relation

This separates the relation from the transport functions, enabling:
1. Symmetric treatment of both directions
2. Modular composition of properties
3. Flexible relation specifications

### Graph-Based Relation Properties

For a relation `R : α → β → Sort w` with transport function `f : α → β`:

1. **Property 0**: The relation itself exists: `R : α → β → Sort w`
2. **Property 1**: A map exists: `map : α → β`
3. **Property 2a**: Map captures relation: `∀ a b, map a = b → R a b`
4. **Property 2b**: Relations imply equality: `∀ a b, R a b → map a = b`
5. **Property 3**: Both 2a and 2b hold
6. **Property 4**: Relations are unique: Combining 2a and 2b forms a bijection between `R a b` and `map a = b`

These properties can hold independently in **covariant** (α → β) and **contravariant** (β → α) directions.

## Property Hierarchy

The properties form a partial order:

```
    4
    ↑
    3
   ↗ ↖
  2a  2b
   ↖ ↗
    1
    ↑
    0
```

- Properties 2a and 2b are incomparable (neither implies the other)
- Property 3 requires both 2a and 2b but not uniqueness (Property 4)
- Property 4 requires 3 and adds uniqueness

### Map Classes

We write `⊡^(n,k) α β` (or `Param nk α β` in Lean) for:
- Covariant direction satisfies properties up to level `n`
- Contravariant direction satisfies properties up to level `k`

Common map classes:
- `Param00`: Just the relation (graph) exists
- `Param10`: Covariant map exists
- `Param11`: Maps exist in both directions
- `Param2a0`: Covariant map with proof of capture
- `Param42b`: Split injection (injective with explicit inverse)
- `Param42a`: Split surjection (surjective with explicit inverse)
- `Param44`: Full equivalence

## Characterizing Relations

### Common Relations

1. **Equivalence** (`Param44 α β`): Types are equivalent
   ```lean
   example : Param44 (R[X,Y]) (R[Y][X])  -- Polynomial representations
   ```

2. **Split Injection** (`Param42b α β`): Injective with right inverse
   ```lean
   example : Param42b (Option γ) (List γ)  -- Option embeds in List
   ```

3. **Split Surjection** (`Param42a α β`): Surjective with left inverse
   ```lean
   example : Param42a (List Prime) Nat  -- Prime factorization
   ```

4. **Simple Mapping** (`Param40 α β`): Just a function preserving relations
   ```lean
   example : Param40 (P = Q) (P' = Q')  -- Implication between equalities
   ```

### Equivalence Theorem

**Theorem**: For types `α` and `β`, having `α ≃ β` (equivalence) is equivalent to having `Param44 α β`.

This connects the Trocq framework to standard mathematical equivalences.

## Type Formers: Arrow and Pi Types

A key feature of Trocq is systematic handling of function types.

### Arrow Types

For `σ → τ`, the relation between functions `f : σ → τ` and `f' : σ' → τ'` is:

```
R_arrow f f' := ∀ (x : σ) (x' : σ') (xR : R_σ x x'), R_τ (f x) (f' x')
```

The covariant map `F_arrow : (σ → τ) → (σ' → τ')` is:
```
F_arrow f := map_τ ∘ f ∘ map_σ'_to_σ
```

### Requirements Table

To construct `Param^(δ) (σ → τ) (σ' → τ')`, we need:

| δ      | Required σ | Required τ |
|--------|-----------|-----------|
| (0,0)  | (0,0)     | (0,0)     |
| (1,0)  | (0,1)     | (1,0)     |
| (2a,0) | (0,2b)    | (2a,0)    |
| (2b,0) | (0,2a)    | (2b,0)    |
| (3,0)  | (0,3)     | (3,0)     |
| (4,0)  | (0,3)     | (4,0)     |

**Note**: The last row needs only `(0,3)` for σ in Lean (vs `(0,4)` in Coq) due to Lean's Uniqueness of Identity Proofs, which makes equality types subsingletons.

### Dependent Pi Types

For dependent functions `Π (x : σ), τ x`, the requirements differ:

| δ      | Required σ | Required τ |
|--------|-----------|-----------|
| (2a,0) | (0,4)     | (2a,0)    |

The contravariant direction needs **uniqueness of relations** (Property 4) because:
- τ depends on the specific relation object between x and x'
- Different relation objects might give different τ types
- Uniqueness ensures consistency

## Universe Relations

### Relating Universes

Trocq extends to relating universes themselves. The parametric sort relation:

```lean
p_Sort : Param^(2a,2a) (Sort u) (Sort u)
```

has relation:
```
(p_Sort).R α β := Param^(k,l) α β
```

This means **the relation between types is having a parametric relation between them**.

### Identity Relation

The identity parametric relation `p_id : Param44 α α` relates a type to itself via equality:
```
(p_id).R a a' := (a = a')
```

This is crucial for:
- Reducing overhead when types don't need transformation
- Handling mixed scenarios (some types transform, others stay the same)
- Eliminating unnecessary relation proofs

### Restrictions in Lean

Without univalence, we can only construct `p_Sort` with:
- Both directions at most level 2a: `Param^(m,n)` where `m,n ≤ 2a`

This is because Property 2b on universes would require `α → β` implies `α = β`, which needs univalence for non-trivial equivalences.

## Abstraction Theorem

**Trocq Abstraction Theorem**: If you can relate:
- Terms: `M : α` and `M' : β` with relation `M_R`
- Types: `α : Sort u` and `β : Sort u` with relation `α_R`

Then the relation objects themselves are related:
```
M_R : rel(α_R) M M'
```

This theorem ensures the framework is internally consistent and properly handles the stratification of types and universes.

## Practical Implications

### When to Use Which Map Class

- **Param44**: Types are equivalent (symmetric, full transport)
- **Param42b**: One-way injection (embed subset into larger type)
- **Param42a**: One-way surjection (quotient to simpler type)
- **Param40**: Simple forward transport (implications, weaker properties)

### Composing Relations

Relations compose using the forgetful functor:
```lean
def forget : Param^(n,k) α β → Param^(m,l) α β  -- where m ≤ n, l ≤ k
```

This allows using stronger relations where weaker ones suffice.

### Flip Functor

Relations can be reversed:
```lean
def flip : Param^(n,k) α β → Param^(k,n) β α
```

This swaps covariant and contravariant directions, enabling bidirectional reasoning.

---

For implementation details, see [implementation.md](implementation.md).  
For practical examples, see [examples.md](examples.md).
